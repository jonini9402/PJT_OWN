<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "https://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.own.domain.post.dao.PostDao">

	<!-- select 문에서 중복되는 sql 조각들을 편리하게 사용하기 위함
	include refid로 사용 -->
	<sql id="selectPostDetails">
		p.post_id           AS postId,
        p.created_at        AS createdAt,
        p.caption           AS caption,
        
        (SELECT workout_type_id 
           FROM post_workout_type pwt 
          WHERE pwt.post_id = p.post_id 
          LIMIT 1)          AS workoutTag,
        
        u.nickname          AS nickname,
        u.profile_img       AS profileImg,
        u.tier_level        AS tierLevel,
        m.title             AS musicTitle,
        m.album_img         AS albumImg,
        m.artist			AS artist,
        m.duration          AS duration,
        m.preview_url       AS previewUrl,
        
        (SELECT COUNT(*) FROM user_post_like l WHERE l.post_id = p.post_id) AS likeCount,
        (SELECT COUNT(*) FROM user_post_bookmark b WHERE b.post_id = p.post_id) AS bookmarkCount,
        
        EXISTS (
            SELECT 1 FROM user_post_like l WHERE l.post_id = p.post_id AND l.user_id = #{loginUserId}
        ) AS isLiked,
        EXISTS (
            SELECT 1 FROM user_post_bookmark b WHERE b.post_id = p.post_id AND b.user_id = #{loginUserId}
        ) AS isBookmarked
    </sql>

	<!--  페이지네이션 관련 정보 : 커서 기반(무한 스크롤) 
		1. lastPostId는 null 
		2. ORDER BY p.post_id DESC: post_id가 높을 수록 최근 글이므로 내림차순으로 정렬 
		3. LIMIT 10으로 10개씩 나오도록 고정 
		4. WHERE p.post_id < 마지막id 조건으로 스크롤더보기 구현-->
		
    <sql id="cursorCondition">
        <if test="lastPostId != null"> 
            AND p.post_id &lt; #{lastPostId}  </if>
    </sql>
    
    <!-- 감정 태그 가져오기 -->
    <select id="selectEmotionTagsByPostId" resultType="string">
    SELECT et.emotion_name
    FROM post_emotion_type pet
    JOIN emotion_type et ON pet.emotion_type_id = et.emotion_type_id
    WHERE pet.post_id = #{postId}
	</select>
	
	<!-- DTO와 DB 결과를 매핑해주는 설정 -->
	<resultMap id="PostResponseMap" type="com.own.domain.post.dto.response.PostResponse" autoMapping="true">
    <id property="postId" column="postId"/>
   
    <collection property="emotionTags" column="postId" 
                select="selectEmotionTagsByPostId" 
                javaType="java.util.List" ofType="string"/>
	</resultMap>
    
	
	
	 <!--  전체 포스트 조회 -->
    <select id="findAll" resultMap="PostResponseMap">
        SELECT 
            <include refid="selectPostDetails"/>
        FROM post p
        LEFT JOIN users u ON p.user_id = u.user_id
        LEFT JOIN music m ON p.music_id = m.music_id
        <where>
            <include refid="cursorCondition"/>
        </where>
        ORDER BY p.post_id DESC  LIMIT 10          
         </select>

	<!--  특정 유저가 작성한 포스트 조회 -->
    <select id="findByUserId" resultMap="PostResponseMap">
        SELECT 
            <include refid="selectPostDetails"/>
        FROM post p
        LEFT JOIN users u ON p.user_id = u.user_id
        LEFT JOIN music m ON p.music_id = m.music_id
        WHERE p.user_id = #{userId} 
        <include refid="cursorCondition"/>
        ORDER BY p.post_id DESC
        LIMIT 10
    </select>

	<!-- 특정 유저가 좋아요한 포스트 조회 -->
    <select id="findLikedPosts" resultMap="PostResponseMap">
        SELECT 
            <include refid="selectPostDetails"/>
        FROM post p
        JOIN user_post_like l ON p.post_id = l.post_id
        LEFT JOIN users u ON p.user_id = u.user_id
        LEFT JOIN music m ON p.music_id = m.music_id
        WHERE l.user_id = #{userId}
        <include refid="cursorCondition"/>
        ORDER BY p.post_id DESC
        LIMIT 10
    </select>

	<!-- 특정 유저가 북마크한 포스트 조회 -->
    <select id="findBookmarkedPosts" resultMap="PostResponseMap">
        SELECT 
            <include refid="selectPostDetails"/>
        FROM post p
        JOIN user_post_bookmark b ON p.post_id = b.post_id
        LEFT JOIN users u ON p.user_id = u.user_id
        LEFT JOIN music m ON p.music_id = m.music_id
        WHERE b.user_id = #{userId}
        <include refid="cursorCondition"/>
        ORDER BY p.post_id DESC
        LIMIT 10
    </select>

	<!-- 포스트 추가 -->
    <insert id="insertPost" useGeneratedKeys="true" keyProperty="postId">
        INSERT INTO post (user_id, music_id, caption, created_at) 
        VALUES (#{userId}, #{musicId}, #{caption}, NOW())
    </insert>
    
    <!-- 감정 타입 추가  -->
    <insert id="insertPostEmotionType">
        INSERT INTO post_emotion_type (post_id, emotion_type_id)
        VALUES (#{postId}, #{emotionTypeId})
    </insert>
    
    <!-- 운동 타입 추가 -->
    <insert id="insertPostWorkoutType">
        INSERT INTO post_workout_type (post_id, workout_type_id)
        VALUES (#{postId}, #{workoutTypeId})
    </insert>
    
    <!-- 포스트 작성 후 생성되는 응답 객체 조회 메서드 -->
	<select id="findPostResponseById" resultType="com.own.domain.post.dto.response.PostResponse">
    	SELECT 
        <include refid="selectPostDetails"/>
    	FROM post p
    	LEFT JOIN users u ON p.user_id = u.user_id
    	LEFT JOIN music m ON p.music_id = m.music_id
    	WHERE p.post_id = #{postId}
	</select>

	<!-- 포스트 수정 -->
	<update id="updatePost">
		UPDATE post
		SET caption =  #{request.caption}
		WHERE post_id = #{postId}
	</update>
	
	<!-- 포스트 수정 시 감정 태그만 삭제 -->
	<delete id="deletePostEmotionTypes">
    DELETE FROM post_emotion_type
    WHERE post_id = #{postId}
</delete>
	
	<!-- 포스트 삭제 -->
	<delete id="deletePost">
		DELETE FROM post
		WHERE post_id = #{postId}
	</delete>


	<!-- 음악 랭킹 조회 -->
	<select id="findMusicRank" parameterType="java.time.LocalDateTime" resultType="com.own.domain.post.dto.response.MusicRankResponse">
		
		SELECT
			workoutName,
			musicTitle,
			artist,
			albumImg,
			previewUrl
		FROM (
			SELECT
				w.workout_name AS workoutName,
				m.title AS musicTitle,
				m.artist AS artist,
				m.album_img AS albumImg,
				m.preview_url AS previewUrl,
				ROW_NUMBER() OVER (
					PARTITION BY w.workout_type_id
					ORDER BY COUNT(p.post_id) DESC, m.music_id ASC
				) AS rnk
			FROM post p
			JOIN music m ON p.music_id = m.music_id
			JOIN post_workout_type pwt ON p.post_id = pwt.post_id
			JOIN workout_type w ON pwt.workout_type_id = w.workout_type_id
			WHERE p.created_at >= #{startDate}
			GROUP BY w.workout_type_id, m.music_id	
		) ranked_music
		WHERE rnk = 1
		ORDER BY workoutName ASC
	
	</select>
	
	<!-- 이번주 운동 횟수 조회 -->
	<select id="countWeeklyPosts" resultType="int">
   SELECT COUNT(*)
    FROM post
    WHERE user_id = #{userId}
      AND created_at >= DATE_SUB(CURDATE(), INTERVAL DAYOFWEEK(CURDATE())-1 DAY)
	</select>
	
	
</mapper>